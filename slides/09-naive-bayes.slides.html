<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="dcterms.date" content="2015-11-24">
  <title>Probabilistic Classification: Naive Bayes</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="reveal.js/css/reveal.css">
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme">
  <link rel="stylesheet" href="talks.css"/>
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_SVG" type="text/javascript"></script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    TeX: {
         extensions: ["color.js"]
      }
    });
  </script>
  <script src="figure-animate.js"></script>
</head>
<body>
\[\newcommand{\tk}[1]{}
%\newcommand{\tk}[1]{\textbf{TK}: #1}
\newcommand{\Amatrix}{\mathbf{A}}
\newcommand{\KL}[2]{\text{KL}\left( #1\,\|\,#2 \right)}
\newcommand{\Kaast}{\kernelMatrix_{\mathbf{ \ast}\mathbf{ \ast}}}
\newcommand{\Kastu}{\kernelMatrix_{\mathbf{ \ast} \inducingVector}}
\newcommand{\Kff}{\kernelMatrix_{\mappingFunctionVector \mappingFunctionVector}}
\newcommand{\Kfu}{\kernelMatrix_{\mappingFunctionVector \inducingVector}}
\newcommand{\Kuast}{\kernelMatrix_{\inducingVector \bf\ast}}
\newcommand{\Kuf}{\kernelMatrix_{\inducingVector \mappingFunctionVector}}
\newcommand{\Kuu}{\kernelMatrix_{\inducingVector \inducingVector}}
\newcommand{\Kuui}{\Kuu^{-1}}
\newcommand{\Qaast}{\mathbf{Q}_{\bf \ast \ast}}
\newcommand{\Qastf}{\mathbf{Q}_{\ast \mappingFunction}}
\newcommand{\Qfast}{\mathbf{Q}_{\mappingFunctionVector \bf \ast}}
\newcommand{\Qff}{\mathbf{Q}_{\mappingFunctionVector \mappingFunctionVector}}
\newcommand{\aMatrix}{\mathbf{A}}
\newcommand{\aScalar}{a}
\newcommand{\aVector}{\mathbf{a}}
\newcommand{\acceleration}{a}
\newcommand{\bMatrix}{\mathbf{B}}
\newcommand{\bScalar}{b}
\newcommand{\bVector}{\mathbf{b}}
\newcommand{\basisFunc}{\phi}
\newcommand{\basisFuncVector}{\boldsymbol{ \basisFunc}}
\newcommand{\basisFunction}{\phi}
\newcommand{\basisLocation}{\mu}
\newcommand{\basisMatrix}{\boldsymbol{ \Phi}}
\newcommand{\basisScalar}{\basisFunction}
\newcommand{\basisVector}{\boldsymbol{ \basisFunction}}
\newcommand{\activationFunction}{\phi}
\newcommand{\activationMatrix}{\boldsymbol{ \Phi}}
\newcommand{\activationScalar}{\basisFunction}
\newcommand{\activationVector}{\boldsymbol{ \basisFunction}}
\newcommand{\bigO}{\mathcal{O}}
\newcommand{\binomProb}{\pi}
\newcommand{\cMatrix}{\mathbf{C}}
\newcommand{\cbasisMatrix}{\hat{\boldsymbol{ \Phi}}}
\newcommand{\cdataMatrix}{\hat{\dataMatrix}}
\newcommand{\cdataScalar}{\hat{\dataScalar}}
\newcommand{\cdataVector}{\hat{\dataVector}}
\newcommand{\centeredKernelMatrix}{\mathbf{ \MakeUppercase{\centeredKernelScalar}}}
\newcommand{\centeredKernelScalar}{b}
\newcommand{\centeredKernelVector}{\centeredKernelScalar}
\newcommand{\centeringMatrix}{\mathbf{H}}
\newcommand{\chiSquaredDist}[2]{\chi_{#1}^{2}\left(#2\right)}
\newcommand{\chiSquaredSamp}[1]{\chi_{#1}^{2}}
\newcommand{\conditionalCovariance}{\boldsymbol{ \Sigma}}
\newcommand{\coregionalizationMatrix}{\mathbf{B}}
\newcommand{\coregionalizationScalar}{b}
\newcommand{\coregionalizationVector}{\mathbf{ \coregionalizationScalar}}
\newcommand{\covDist}[2]{\text{cov}_{#2}\left(#1\right)}
\newcommand{\covSamp}[1]{\text{cov}\left(#1\right)}
\newcommand{\covarianceScalar}{c}
\newcommand{\covarianceVector}{\mathbf{ \covarianceScalar}}
\newcommand{\covarianceMatrix}{\mathbf{C}}
\newcommand{\covarianceMatrixTwo}{\boldsymbol{ \Sigma}}
\newcommand{\croupierScalar}{s}
\newcommand{\croupierVector}{\mathbf{ \croupierScalar}}
\newcommand{\croupierMatrix}{\mathbf{ \MakeUppercase{\croupierScalar}}}
\newcommand{\dataDim}{p}
\newcommand{\dataIndex}{i}
\newcommand{\dataIndexTwo}{j}
\newcommand{\dataMatrix}{\mathbf{Y}}
\newcommand{\dataScalar}{y}
\newcommand{\dataSet}{\mathcal{D}}
\newcommand{\dataStd}{\sigma}
\newcommand{\dataVector}{\mathbf{ \dataScalar}}
\newcommand{\decayRate}{d}
\newcommand{\degreeMatrix}{\mathbf{ \MakeUppercase{\degreeScalar}}}
\newcommand{\degreeScalar}{d}
\newcommand{\degreeVector}{\mathbf{ \degreeScalar}}
% Already defined by latex
%\newcommand{\det}[1]{\left|#1\right|}
\newcommand{\diag}[1]{\text{diag}\left(#1\right)}
\newcommand{\diagonalMatrix}{\mathbf{D}}
\newcommand{\diff}[2]{\frac{\text{d}#1}{\text{d}#2}}
\newcommand{\diffTwo}[2]{\frac{\text{d}^2#1}{\text{d}#2^2}}
\newcommand{\displacement}{x}
\newcommand{\displacementVector}{\textbf{\displacement}}
\newcommand{\distanceMatrix}{\mathbf{ \MakeUppercase{\distanceScalar}}}
\newcommand{\distanceScalar}{d}
\newcommand{\distanceVector}{\mathbf{ \distanceScalar}}
\newcommand{\eigenvaltwo}{\ell}
\newcommand{\eigenvaltwoMatrix}{\mathbf{L}}
\newcommand{\eigenvaltwoVector}{\mathbf{l}}
\newcommand{\eigenvalue}{\lambda}
\newcommand{\eigenvalueMatrix}{\boldsymbol{ \Lambda}}
\newcommand{\eigenvalueVector}{\boldsymbol{ \lambda}}
\newcommand{\eigenvector}{\mathbf{ \eigenvectorScalar}}
\newcommand{\eigenvectorMatrix}{\mathbf{U}}
\newcommand{\eigenvectorScalar}{u}
\newcommand{\eigenvectwo}{\mathbf{v}}
\newcommand{\eigenvectwoMatrix}{\mathbf{V}}
\newcommand{\eigenvectwoScalar}{v}
\newcommand{\entropy}[1]{\mathcal{H}\left(#1\right)}
\newcommand{\errorFunction}{E}
\newcommand{\expDist}[2]{\left<#1\right>_{#2}}
\newcommand{\expSamp}[1]{\left<#1\right>}
\newcommand{\expectation}[1]{\left\langle #1 \right\rangle }
\newcommand{\expectationDist}[2]{\left\langle #1 \right\rangle _{#2}}
\newcommand{\expectedDistanceMatrix}{\mathcal{D}}
\newcommand{\eye}{\mathbf{I}}
\newcommand{\fantasyDim}{r}
\newcommand{\fantasyMatrix}{\mathbf{ \MakeUppercase{\fantasyScalar}}}
\newcommand{\fantasyScalar}{z}
\newcommand{\fantasyVector}{\mathbf{ \fantasyScalar}}
\newcommand{\featureStd}{\varsigma}
\newcommand{\gammaCdf}[3]{\mathcal{GAMMA CDF}\left(#1|#2,#3\right)}
\newcommand{\gammaDist}[3]{\mathcal{G}\left(#1|#2,#3\right)}
\newcommand{\gammaSamp}[2]{\mathcal{G}\left(#1,#2\right)}
\newcommand{\gaussianDist}[3]{\mathcal{N}\left(#1|#2,#3\right)}
\newcommand{\gaussianSamp}[2]{\mathcal{N}\left(#1,#2\right)}
\newcommand{\given}{|}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\heaviside}{H}
\newcommand{\hiddenMatrix}{\mathbf{ \MakeUppercase{\hiddenScalar}}}
\newcommand{\hiddenScalar}{h}
\newcommand{\hiddenVector}{\mathbf{ \hiddenScalar}}
\newcommand{\identityMatrix}{\eye}
\newcommand{\inducingInputScalar}{z}
\newcommand{\inducingInputVector}{\mathbf{ \inducingInputScalar}}
\newcommand{\inducingInputMatrix}{\mathbf{Z}}
\newcommand{\inducingScalar}{u}
\newcommand{\inducingVector}{\mathbf{ \inducingScalar}}
\newcommand{\inducingMatrix}{\mathbf{U}}
\newcommand{\inlineDiff}[2]{\text{d}#1/\text{d}#2}
\newcommand{\inputDim}{q}
\newcommand{\inputMatrix}{\mathbf{X}}
\newcommand{\inputScalar}{x}
\newcommand{\inputSpace}{\mathcal{X}}
\newcommand{\inputVals}{\inputVector}
\newcommand{\inputVector}{\mathbf{ \inputScalar}}
\newcommand{\iterNum}{k}
\newcommand{\kernel}{\kernelScalar}
\newcommand{\kernelMatrix}{\mathbf{K}}
\newcommand{\kernelScalar}{k}
\newcommand{\kernelVector}{\mathbf{ \kernelScalar}}
\newcommand{\kff}{\kernelScalar_{\mappingFunction \mappingFunction}}
\newcommand{\kfu}{\kernelVector_{\mappingFunction \inducingScalar}}
\newcommand{\kuf}{\kernelVector_{\inducingScalar \mappingFunction}}
\newcommand{\kuu}{\kernelVector_{\inducingScalar \inducingScalar}}
\newcommand{\lagrangeMultiplier}{\lambda}
\newcommand{\lagrangeMultiplierMatrix}{\boldsymbol{ \Lambda}}
\newcommand{\lagrangian}{L}
\newcommand{\laplacianFactor}{\mathbf{ \MakeUppercase{\laplacianFactorScalar}}}
\newcommand{\laplacianFactorScalar}{m}
\newcommand{\laplacianFactorVector}{\mathbf{ \laplacianFactorScalar}}
\newcommand{\laplacianMatrix}{\mathbf{L}}
\newcommand{\laplacianScalar}{\ell}
\newcommand{\laplacianVector}{\mathbf{ \ell}}
\newcommand{\latentDim}{q}
\newcommand{\latentDistanceMatrix}{\boldsymbol{ \Delta}}
\newcommand{\latentDistanceScalar}{\delta}
\newcommand{\latentDistanceVector}{\boldsymbol{ \delta}}
\newcommand{\latentForce}{f}
\newcommand{\latentFunction}{u}
\newcommand{\latentFunctionVector}{\mathbf{ \latentFunction}}
\newcommand{\latentFunctionMatrix}{\mathbf{ \MakeUppercase{\latentFunction}}}
\newcommand{\latentIndex}{j}
\newcommand{\latentScalar}{z}
\newcommand{\latentVector}{\mathbf{ \latentScalar}}
\newcommand{\latentMatrix}{\mathbf{Z}}
\newcommand{\learnRate}{\eta}
\newcommand{\lengthScale}{\ell}
\newcommand{\rbfWidth}{\ell}
\newcommand{\likelihoodBound}{\mathcal{L}}
\newcommand{\likelihoodFunction}{L}
\newcommand{\locationScalar}{\mu}
\newcommand{\locationVector}{\boldsymbol{ \locationScalar}}
\newcommand{\locationMatrix}{\mathbf{M}}
\newcommand{\variance}[1]{\text{var}\left( #1 \right)}
\newcommand{\mappingFunction}{f}
\newcommand{\mappingFunctionMatrix}{\mathbf{F}}
\newcommand{\mappingFunctionTwo}{g}
\newcommand{\mappingFunctionTwoMatrix}{\mathbf{G}}
\newcommand{\mappingFunctionTwoVector}{\mathbf{ \mappingFunctionTwo}}
\newcommand{\mappingFunctionVector}{\mathbf{ \mappingFunction}}
\newcommand{\scaleScalar}{s}
\newcommand{\mappingScalar}{w}
\newcommand{\mappingVector}{\mathbf{ \mappingScalar}}
\newcommand{\mappingMatrix}{\mathbf{W}}
\newcommand{\mappingScalarTwo}{v}
\newcommand{\mappingVectorTwo}{\mathbf{ \mappingScalarTwo}}
\newcommand{\mappingMatrixTwo}{\mathbf{V}}
\newcommand{\maxIters}{K}
\newcommand{\meanMatrix}{\mathbf{M}}
\newcommand{\meanScalar}{\mu}
\newcommand{\meanTwoMatrix}{\mathbf{M}}
\newcommand{\meanTwoScalar}{m}
\newcommand{\meanTwoVector}{\mathbf{ \meanTwoScalar}}
\newcommand{\meanVector}{\boldsymbol{ \meanScalar}}
\newcommand{\mrnaConcentration}{m}
\newcommand{\naturalFrequency}{\omega}
\newcommand{\neighborhood}[1]{\mathcal{N}\left( #1 \right)}
\newcommand{\neilurl}{http://inverseprobability.com/}
\newcommand{\noiseMatrix}{\boldsymbol{ E}}
\newcommand{\noiseScalar}{\epsilon}
\newcommand{\noiseVector}{\boldsymbol{ \epsilon}}
\newcommand{\norm}[1]{\left\Vert #1 \right\Vert}
\newcommand{\normalizedLaplacianMatrix}{\hat{\mathbf{L}}}
\newcommand{\normalizedLaplacianScalar}{\hat{\ell}}
\newcommand{\normalizedLaplacianVector}{\hat{\mathbf{ \ell}}}
\newcommand{\numActive}{m}
\newcommand{\numBasisFunc}{m}
\newcommand{\numComponents}{m}
\newcommand{\numComps}{K}
\newcommand{\numData}{n}
\newcommand{\numFeatures}{K}
\newcommand{\numHidden}{h}
\newcommand{\numInducing}{m}
\newcommand{\numLayers}{\ell}
\newcommand{\numNeighbors}{K}
\newcommand{\numSequences}{s}
\newcommand{\numSuccess}{s}
\newcommand{\numTasks}{m}
\newcommand{\numTime}{T}
\newcommand{\numTrials}{S}
\newcommand{\outputIndex}{j}
\newcommand{\paramVector}{\boldsymbol{ \theta}}
\newcommand{\parameterMatrix}{\boldsymbol{ \Theta}}
\newcommand{\parameterScalar}{\theta}
\newcommand{\parameterVector}{\boldsymbol{ \parameterScalar}}
\newcommand{\partDiff}[2]{\frac{\partial#1}{\partial#2}}
\newcommand{\precisionScalar}{j}
\newcommand{\precisionVector}{\mathbf{ \precisionScalar}}
\newcommand{\precisionMatrix}{\mathbf{J}}
\newcommand{\pseudotargetScalar}{\widetilde{y}}
\newcommand{\pseudotargetVector}{\mathbf{ \pseudotargetScalar}}
\newcommand{\pseudotargetMatrix}{\mathbf{ \widetilde{Y}}}
\newcommand{\rank}[1]{\text{rank}\left(#1\right)}
\newcommand{\rayleighDist}[2]{\mathcal{R}\left(#1|#2\right)}
\newcommand{\rayleighSamp}[1]{\mathcal{R}\left(#1\right)}
\newcommand{\responsibility}{r}
\newcommand{\rotationScalar}{r}
\newcommand{\rotationVector}{\mathbf{ \rotationScalar}}
\newcommand{\rotationMatrix}{\mathbf{R}}
\newcommand{\sampleCovScalar}{s}
\newcommand{\sampleCovVector}{\mathbf{ \sampleCovScalar}}
\newcommand{\sampleCovMatrix}{\mathbf{s}}
\newcommand{\scalarProduct}[2]{\left\langle{#1},{#2}\right\rangle}
\newcommand{\sign}[1]{\text{sign}\left(#1\right)}
\newcommand{\sigmoid}[1]{\sigma\left(#1\right)}
\newcommand{\singularvalue}{\ell}
\newcommand{\singularvalueMatrix}{\mathbf{L}}
\newcommand{\singularvalueVector}{\mathbf{l}}
\newcommand{\sorth}{\mathbf{u}}
\newcommand{\spar}{\lambda}
\newcommand{\trace}[1]{\text{tr}\left(#1\right)}
\newcommand{\BasalRate}{B}
\newcommand{\DampingCoefficient}{C}
\newcommand{\DecayRate}{D}
\newcommand{\Displacement}{X}
\newcommand{\LatentForce}{F}
\newcommand{\Mass}{M}
\newcommand{\Sensitivity}{S}
\newcommand{\basalRate}{b}
\newcommand{\dampingCoefficient}{c}
\newcommand{\mass}{m}
\newcommand{\sensitivity}{s}
\newcommand{\springScalar}{\kappa}
\newcommand{\springVector}{\boldsymbol{ \kappa}}
\newcommand{\springMatrix}{\boldsymbol{ \mathcal{K}}}
\newcommand{\tfConcentration}{p}
\newcommand{\tfDecayRate}{\delta}
\newcommand{\tfMrnaConcentration}{f}
\newcommand{\tfVector}{\mathbf{ \tfConcentration}}
\newcommand{\velocity}{v}
\newcommand{\sufficientStatsScalar}{g}
\newcommand{\sufficientStatsVector}{\mathbf{ \sufficientStatsScalar}}
\newcommand{\sufficientStatsMatrix}{\mathbf{G}}
\newcommand{\switchScalar}{s}
\newcommand{\switchVector}{\mathbf{ \switchScalar}}
\newcommand{\switchMatrix}{\mathbf{S}}
\newcommand{\tr}[1]{\text{tr}\left(#1\right)}
\newcommand{\loneNorm}[1]{\left\Vert #1 \right\Vert_1}
\newcommand{\ltwoNorm}[1]{\left\Vert #1 \right\Vert_2}
\newcommand{\onenorm}[1]{\left\vert#1\right\vert_1}
\newcommand{\twonorm}[1]{\left\Vert #1 \right\Vert}
\newcommand{\vScalar}{v}
\newcommand{\vVector}{\mathbf{v}}
\newcommand{\vMatrix}{\mathbf{V}}
\newcommand{\varianceDist}[2]{\text{var}_{#2}\left( #1 \right)}
% Already defined by latex
%\newcommand{\vec}{#1:}
\newcommand{\vecb}[1]{\left(#1\right):}
\newcommand{\weightScalar}{w}
\newcommand{\weightVector}{\mathbf{ \weightScalar}}
\newcommand{\weightMatrix}{\mathbf{W}}
\newcommand{\weightedAdjacencyMatrix}{\mathbf{A}}
\newcommand{\weightedAdjacencyScalar}{a}
\newcommand{\weightedAdjacencyVector}{\mathbf{ \weightedAdjacencyScalar}}
\newcommand{\onesVector}{\mathbf{1}}
\newcommand{\zerosVector}{\mathbf{0}}
\]
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">Probabilistic Classification: Naive Bayes</h1>
  <p class="author" style="text-align:center"><a href="http://inverseprobability.com">Neil D. Lawrence</a></p>
  <p class="date" style="text-align:center"><time>2015-11-24</time></p>
  <p class="venue" style="text-align:center">University of Sheffield</p>
</section>

<section class="slide level2">

<!-- Do not edit this file locally. -->
<!---->
<!-- Do not edit this file locally. -->
<!-- The last names to be defined. Should be defined entirely in terms of macros from above-->
<!--

-->
</section>
<section id="review" class="slide level2">
<h2>Review</h2>
<ul>
<li>Last time: Looked at unsupervised learning.</li>
<li>Introduced latent variables, dimensionality reduction and clustering.</li>
<li>This time: Classification with Naive Bayes</li>
</ul>
</section>
<section id="introduction-to-classification" class="slide level2">
<h2>Introduction to Classification</h2>
</section>
<section id="classification" class="slide level2">
<h2>Classification</h2>
<ul>
<li><em>Wake word</em> classification (<a href="https://radio.unglobalpulse.net/uganda/">Global Pulse Project</a>).</li>
<li>Breakthrough in 2012 with ImageNet result of <a href="http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-">Alex Krizhevsky, Ilya Sutskever and Geoff Hinton</a></li>
</ul>
<ul>
<li>We are given a data set containing ‘inputs’, <span class="math inline">\(\inputMatrix\)</span> and ‘targets’, <span class="math inline">\(\dataVector\)</span>.</li>
<li>Each data point consists of an input vector <span class="math inline">\(\inputVector_i\)</span> and a class label, <span class="math inline">\(\dataScalar_i\)</span>.</li>
<li>For binary classification assume <span class="math inline">\(\dataScalar_i\)</span> should be either <span class="math inline">\(1\)</span> (yes) or <span class="math inline">\(-1\)</span> (no).</li>
<li>Input vector can be thought of as features.</li>
</ul>
</section>
<section id="discrete-probability" class="slide level2">
<h2>Discrete Probability</h2>
<ul>
<li>Algorithms based on <em>prediction</em> function and <em>objective</em> function.</li>
<li>For regression the <em>codomain</em> of the functions, <span class="math inline">\(f(\inputMatrix)\)</span> was the real numbers or sometimes real vectors.</li>
<li>In classification we are given an input vector, <span class="math inline">\(\inputVector\)</span>, and an associated label, <span class="math inline">\(\dataScalar\)</span> which either takes the value <span class="math inline">\(-1\)</span> or <span class="math inline">\(1\)</span>.</li>
</ul>
</section>
<section id="classification-1" class="slide level2">
<h2>Classification</h2>
<ul>
<li>Inputs, <span class="math inline">\(\inputVector\)</span>, mapped to a label, <span class="math inline">\(\dataScalar\)</span>, through a function <span class="math inline">\(\mappingFunction(\cdot)\)</span> dependent on parameters, <span class="math inline">\(\weightVector\)</span>, <span class="math display">\[
\dataScalar = \mappingFunction(\inputVector; \weightVector).
\]</span></li>
<li><span class="math inline">\(\mappingFunction(\cdot)\)</span> is known as the <em>prediction function</em>. </li>
</ul>
</section>
<section id="classification-examples" class="slide level2">
<h2>Classification Examples</h2>
<ul>
<li>Classifiying hand written digits from binary images (automatic zip code reading)</li>
<li>Detecting faces in images (e.g. digital cameras).</li>
<li>Who a detected face belongs to (e.g. Facebook, DeepFace)</li>
<li>Classifying type of cancer given gene expression data.</li>
<li>Categorization of document types (different types of news article on the internet)</li>
</ul>
</section>
<section id="reminder-on-the-term-bayesian" class="slide level2">
<h2>Reminder on the Term “Bayesian”</h2>
<ul>
<li>We use Bayes’ rule to invert probabilities in the Bayesian approach.
<ul>
<li>Bayesian is not named after Bayes’ rule (v. common confusion).</li>
<li>The term Bayesian refers to the treatment of the parameters as stochastic variables.</li>
<li>Proposed by <span class="citation" data-cites="Laplace:memoire74">Laplace (1774)</span> and <span class="citation" data-cites="Bayes:doctrine63">Bayes (1763)</span> independently.</li>
<li>For early statisticians this was very controversial (Fisher et al).</li>
</ul></li>
</ul>
</section>
<section id="reminder-on-the-term-bayesian-1" class="slide level2">
<h2>Reminder on the Term “Bayesian”</h2>
<ul>
<li>The use of Bayes’ rule does <em>not</em> imply you are being Bayesian.
<ul>
<li>It is just an application of the product rule of probability.</li>
</ul></li>
</ul>
</section>
<section id="bernoulli-distribution" class="slide level2">
<h2>Bernoulli Distribution</h2>
<ul>
<li>Binary classification: need a probability distribution for discrete variables.</li>
<li>Discrete probability is in some ways easier: <span class="math inline">\(P(\dataScalar=1) = \pi\)</span> &amp; specify distribution as a table.</li>
<li>Instead of <span class="math inline">\(\dataScalar=-1\)</span> for negative class we take <span class="math inline">\(\dataScalar=0\)</span>. </li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(\dataScalar\)</span></th>
<th style="text-align: center;">0</th>
<th style="text-align: center;">1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(P(\dataScalar)\)</span></td>
<td style="text-align: center;"><span class="math inline">\((1-\pi)\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\pi\)</span></td>
</tr>
</tbody>
</table>
<p>This is the <a href="http://en.wikipedia.org/wiki/Bernoulli_distribution">Bernoulli distribution</a>.</p>
</section>
<section id="mathematical-switch" class="slide level2">
<h2>Mathematical Switch</h2>
<ul>
<li>The Bernoulli distribution <span class="math display">\[
P(\dataScalar) = \pi^\dataScalar (1-\pi)^{(1-\dataScalar)}
\]</span> </li>
<li>Is a clever trick for switching probabilities, as code it would be</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">def</span> bernoulli(y_i, pi):</span>
<span id="cb1-2"><a href="#cb1-2"></a>    <span class="cf">if</span> y_i <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb1-3"><a href="#cb1-3"></a>        <span class="cf">return</span> pi</span>
<span id="cb1-4"><a href="#cb1-4"></a>    <span class="cf">else</span>:</span>
<span id="cb1-5"><a href="#cb1-5"></a>        <span class="cf">return</span> <span class="dv">1</span><span class="op">-</span>pi</span></code></pre></div>
</section>
<section id="jacob-bernoullis-bernoulli" class="slide level2">
<h2>Jacob Bernoulli’s Bernoulli</h2>
<ul>
<li>Bernoulli described the Bernoulli distribution in terms of an ‘urn’ filled with balls.</li>
<li>There are red and black balls. There is a fixed number of balls in the urn.</li>
<li>The portion of red balls is given by <span class="math inline">\(\pi\)</span>.</li>
<li>For this reason in Bernoulli’s distribution there is <em>epistemic</em> uncertainty about the distribution parameter. </li>
</ul>
</section>
<section id="section" class="slide level2">
<h2></h2>
<iframe frameborder="0" scrolling="no" style="border:0px" src="http://books.google.co.uk/books?id=CF4UAAAAQAAJ&amp;pg=PA87&amp;output=embed" width="700" height="500">
</iframe>
</section>
<section id="jacob-bernoullis-bernoulli-1" class="slide level2">
<h2>Jacob Bernoulli’s Bernoulli</h2>
<div class="figure">
<div id="bernoulli-urn-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/ml/bernoulli-urn.svg" width="40%" style=" ">
</object>
</div>
</div>
</section>
<section id="thomas-bayess-bernoulli" class="slide level2">
<h2>Thomas Bayes’s Bernoulli</h2>
<ul>
<li>Bayes described the Bernoulli distribution (he didn’t call it that!) in terms of a table and two balls.</li>
<li>Each ball is rolled so it comes to rest at a uniform distribution across the table.</li>
<li>The first ball comes to rest at a position that is a <span class="math inline">\(\pi\)</span> times the width of table.</li>
<li>After placing the first ball you consider whether a second would land to the left or the right.</li>
<li>For this reason in Bayes’s distribution there is considered to be <em>aleatoric</em> uncertainty about the distribution parameter. \notes{Thomas Bayes also described the Bernoulli distribution, only he didn’t refer to Jacob Bernoulli’s work, so he didn’t call it by that name. He described the distribution in terms of a table (think of a <em>billiard table</em>) and two balls. Bayes suggests that each ball can be rolled across the table such that it comes to rest at a position that is <em>uniformly distributed</em> between the sides of the table.</li>
</ul>
<p>Let’s assume that the first ball is rolled, and that it comes to reset at a position that is <span class="math inline">\(\pi\)</span> times the width of the table from the left hand side.</p>
<p>Now, we roll the second ball. We are interested if the second ball ends up on the left side (+ve result) or the right side (-ve result) of the first ball. We use the Bernoulli distribution to determine this.</p>
<p>For this reason in Bayes’s distribution there is considered to be <em>aleatoric</em> uncertainty about the distribution parameter.}</p>
</section>
<section id="thomas-bayes-bernoulli" class="slide level2">
<h2>Thomas Bayes’ Bernoulli</h2>
<script>
showDivs(1, 'bayes_billiard');
</script>
<p><small></small> <input id="range-bayes_billiard" type="range" min="1" max="10" value="1" onchange="setDivs('bayes_billiard')" oninput="setDivs('bayes_billiard')"> <button onclick="plusDivs(-1, 'bayes_billiard')">❮</button> <button onclick="plusDivs(1, 'bayes_billiard')">❯</button></p>
</section>
<section id="section-1" class="slide level2">
<h2></h2>
<div class="bayes_billiard" style="text-align:center;">
<object class="svgplot " data="../slides/diagrams/ml/bayes-billiard000.svg" width="40%" style=" ">
</object>
</div>
</section>
<section id="section-2" class="slide level2">
<h2></h2>
<div class="bayes_billiard" style="text-align:center;">
<object class="svgplot " data="../slides/diagrams/ml/bayes-billiard001.svg" width="40%" style=" ">
</object>
</div>
</section>
<section id="section-3" class="slide level2">
<h2></h2>
<div class="bayes_billiard" style="text-align:center;">
<object class="svgplot " data="../slides/diagrams/ml/bayes-billiard002.svg" width="40%" style=" ">
</object>
</div>
</section>
<section id="section-4" class="slide level2">
<h2></h2>
<div class="bayes_billiard" style="text-align:center;">
<object class="svgplot " data="../slides/diagrams/ml/bayes-billiard003.svg" width="40%" style=" ">
</object>
</div>
</section>
<section id="section-5" class="slide level2">
<h2></h2>
<div class="bayes_billiard" style="text-align:center;">
<object class="svgplot " data="../slides/diagrams/ml/bayes-billiard004.svg" width="40%" style=" ">
</object>
</div>
</section>
<section id="section-6" class="slide level2">
<h2></h2>
<div class="bayes_billiard" style="text-align:center;">
<object class="svgplot " data="../slides/diagrams/ml/bayes-billiard005.svg" width="40%" style=" ">
</object>
</div>
</section>
<section id="section-7" class="slide level2">
<h2></h2>
<div class="bayes_billiard" style="text-align:center;">
<object class="svgplot " data="../slides/diagrams/ml/bayes-billiard006.svg" width="40%" style=" ">
</object>
</div>
</section>
<section id="section-8" class="slide level2">
<h2></h2>
<div class="bayes_billiard" style="text-align:center;">
<object class="svgplot " data="../slides/diagrams/ml/bayes-billiard007.svg" width="40%" style=" ">
</object>
</div>
</section>
<section id="section-9" class="slide level2">
<h2></h2>
<div class="bayes_billiard" style="text-align:center;">
<object class="svgplot " data="../slides/diagrams/ml/bayes-billiard008.svg" width="40%" style=" ">
</object>
</div>
</section>
<section id="section-10" class="slide level2">
<h2></h2>
<div class="bayes_billiard" style="text-align:center;">
<object class="svgplot " data="../slides/diagrams/ml/bayes-billiard009.svg" width="40%" style=" ">
</object>
</div>
</section>
<section id="maximum-likelihood-in-the-bernoulli" class="slide level2">
<h2>Maximum Likelihood in the Bernoulli</h2>
<ul>
<li>Assume data, <span class="math inline">\(\dataVector\)</span> is binary vector length <span class="math inline">\(\numData\)</span>.</li>
<li>Assume each value was sampled independently from the Bernoulli distribution, given probability <span class="math inline">\(\pi\)</span> <span class="math display">\[
p(\dataVector|\pi) = \prod_{i=1}^{\numData} \pi^{\dataScalar_i} (1-\pi)^{1-\dataScalar_i}.
\]</span> </li>
</ul>
</section>
<section id="negative-log-likelihood" class="slide level2">
<h2>Negative Log Likelihood</h2>
<ul>
<li>Minimize the negative log likelihood <span class="math display">\[\begin{align*}
\errorFunction(\pi)&amp; = -\log p(\dataVector|\pi)\\ 
                   &amp; = -\sum_{i=1}^{\numData} \dataScalar_i \log \pi - \sum_{i=1}^{\numData} (1-\dataScalar_i) \log(1-\pi),
\end{align*}\]</span></li>
<li>Take gradient with respect to the parameter <span class="math inline">\(\pi\)</span>. <span class="math display">\[\frac{\text{d}\errorFunction(\pi)}{\text{d}\pi} = -\frac{\sum_{i=1}^{\numData} \dataScalar_i}{\pi}  + \frac{\sum_{i=1}^{\numData} (1-\dataScalar_i)}{1-\pi},\]</span></li>
</ul>
</section>
<section id="fixed-point" class="slide level2">
<h2>Fixed Point</h2>
<ul>
<li>Stationary point: set derivative to zero <span class="math display">\[0 = -\frac{\sum_{i=1}^{\numData} \dataScalar_i}{\pi}  + \frac{\sum_{i=1}^{\numData} (1-\dataScalar_i)}{1-\pi},\]</span> </li>
<li>Rearrange to form <span class="math display">\[(1-\pi)\sum_{i=1}^{\numData} \dataScalar_i =   \pi\sum_{i=1}^{\numData} (1-\dataScalar_i),\]</span> </li>
<li>Giving <span class="math display">\[\sum_{i=1}^{\numData} \dataScalar_i =   \pi\left(\sum_{i=1}^{\numData} (1-\dataScalar_i) + \sum_{i=1}^{\numData} \dataScalar_i\right),\]</span></li>
</ul>
</section>
<section id="solution" class="slide level2">
<h2>Solution</h2>
<ul>
<li><p>Recognise that <span class="math inline">\(\sum_{i=1}^{\numData} (1-\dataScalar_i) + \sum_{i=1}^{\numData} \dataScalar_i = n\)</span> so we have <span class="math display">\[\pi = \frac{\sum_{i=1}^{\numData} \dataScalar_i}{\numData}\]</span></p></li>
<li><p>Estimate the probability associated with the Bernoulli by setting it to the number of observed positives, divided by the total length of <span class="math inline">\(\dataScalar\)</span>.</p></li>
<li><p>Makes intiutive sense.</p></li>
<li><p>What’s your best guess of probability for coin toss is heads when you get 47 heads from 100 tosses?</p></li>
</ul>
</section>
<section id="exercise-2" class="slide level2">
<h2>Exercise 2</h2>
<p>Show that the maximum likelihood solution we have found is a <em>minimum</em> for our objective.</p>
</section>
<section id="bayes-rule-reminder" class="slide level2">
<h2>Bayes’ Rule Reminder</h2>
<p><span class="math display">\[
\text{posterior} =
\frac{\text{likelihood}\times\text{prior}}{\text{marginal likelihood}}
\]</span></p>
<p>Four components:</p>
<ol type="1">
<li>Prior distribution</li>
<li>Likelihood</li>
<li>Posterior distribution</li>
<li>Marginal likelihood</li>
</ol>
</section>
<section id="naive-bayes-classifiers" class="slide level2">
<h2>Naive Bayes Classifiers</h2>
<ul>
<li>Probabilistic Machine Learning: place probability distributions (or densities) over all the variables of interest.</li>
<li>In <em>naive Bayes</em> this is exactly what we do.</li>
</ul>
<ul>
<li>Form a classification algorithm by modelling the <em>joint</em> density of our observations. </li>
</ul>
<ul>
<li>Need to make assumption about joint density.</li>
</ul>
</section>
<section id="assumptions-about-density" class="slide level2">
<h2>Assumptions about Density</h2>
<ul>
<li>Make assumptions to reduce the number of parameters we need to optimise.</li>
<li>Given label data <span class="math inline">\(\dataVector\)</span> and the inputs <span class="math inline">\(\inputMatrix\)</span> could specify joint density of all potential values of <span class="math inline">\(\dataVector\)</span> and <span class="math inline">\(\inputMatrix\)</span>, <span class="math inline">\(p(\dataVector, \inputMatrix)\)</span>.</li>
<li>If <span class="math inline">\(\inputMatrix\)</span> and <span class="math inline">\(\dataVector\)</span> are training data.</li>
<li>If <span class="math inline">\(\inputVector^*\)</span> is a test input and <span class="math inline">\(\dataScalar^*\)</span> a test location we want <span class="math display">\[
p(\dataScalar^*|\inputMatrix, \dataVector, \inputVector^*),
\]</span></li>
</ul>
</section>
<section id="answer-from-rules-of-probability" class="slide level2">
<h2>Answer from Rules of Probability</h2>
<ul>
<li>Compute this distribution using the product and sum rules.</li>
<li>Need the probability associated with all possible combinations of <span class="math inline">\(\dataVector\)</span> and <span class="math inline">\(\inputMatrix\)</span>.</li>
<li>There are <span class="math inline">\(2^{\numData}\)</span> possible combinations for the vector <span class="math inline">\(\dataVector\)</span></li>
<li>Probability for each of these combinations must be jointly specified along with the joint density of the matrix <span class="math inline">\(\inputMatrix\)</span>,</li>
<li>Also need to <em>extend</em> the density for any chosen test location <span class="math inline">\(\inputVector^*\)</span>.</li>
</ul>
</section>
<section id="naive-bayes-assumptions" class="slide level2">
<h2>Naive Bayes Assumptions</h2>
<ul>
<li>In <em>naive Bayes</em> we make certain simplifying assumptions that allow us to perform all of the above in practice.</li>
</ul>
<ol type="1">
<li>Data Conditional Independence</li>
<li>Feature conditional independence</li>
<li>Marginal density for <span class="math inline">\(\dataScalar\)</span>.</li>
</ol>
</section>
<section id="data-conditional-independence" class="slide level2">
<h2>Data Conditional Independence</h2>
<ul>
<li>Given model parameters <span class="math inline">\(\paramVector\)</span> we assume that all data points in the model are independent. <span class="math display">\[
p(\dataScalar^*, \inputVector^*, \dataVector, \inputMatrix|\paramVector) = p(\dataScalar^*, \inputVector^*|\paramVector)\prod_{i=1}^{\numData} p(\dataScalar_i, \inputVector_i | \paramVector).
\]</span> </li>
<li>This is a conditional independence assumption. </li>
<li>We also make similar assumptions for regression (where <span class="math inline">\(\paramVector = \left\{\mappingVector,\dataStd^2\right\}\)</span>). </li>
<li>Here we assume <em>joint</em> density of <span class="math inline">\(\dataVector\)</span> and <span class="math inline">\(\inputMatrix\)</span> is independent across the data given the parameters.</li>
</ul>
</section>
<section id="bayes-classifier" class="slide level2">
<h2>Bayes Classifier</h2>
<p>Computing posterior distribution in this case becomes easier, this is known as the ‘Bayes classifier’.</p>
</section>
<section id="feature-conditional-independence" class="slide level2">
<h2>Feature Conditional Independence</h2>
<ul>
<li>Particular to naive Bayes: assume <em>features</em> are also conditionally independent, given param <em>and</em> the label. <span class="math display">\[p(\inputVector_i | \dataScalar_i, \paramVector) = \prod_{j=1}^{\dataDim} p(\inputScalar_{i,j}|\dataScalar_i,\paramVector)\]</span> where <span class="math inline">\(\dataDim\)</span> is the dimensionality of our inputs.</li>
<li>This is known as the <em>naive Bayes</em> assumption.</li>
<li>Bayes classifier + feature conditional independence.</li>
</ul>
</section>
<section id="marginal-density-for-datascalar_i" class="slide level2">
<h2>Marginal Density for <span class="math inline">\(\dataScalar_i\)</span></h2>
<ul>
<li>To specify the joint distribution we also need the marginal for <span class="math inline">\(p(\dataScalar_i)\)</span> <span class="math display">\[p(\inputScalar_{i,j},\dataScalar_i| \paramVector) = p(\inputScalar_{i,j}|\dataScalar_i, \paramVector)p(\dataScalar_i).\]</span> </li>
<li>Because <span class="math inline">\(\dataScalar_i\)</span> is binary the <em>Bernoulli</em> density makes a suitable choice for our prior over <span class="math inline">\(\dataScalar_i\)</span>, <span class="math display">\[p(\dataScalar_i|\pi) = \pi^{\dataScalar_i} (1-\pi)^{1-\dataScalar_i}\]</span> where <span class="math inline">\(\pi\)</span> now has the interpretation as being the <em>prior</em> probability that the classification should be positive.</li>
</ul>
</section>
<section id="joint-density-for-naive-bayes" class="slide level2">
<h2>Joint Density for Naive Bayes</h2>
<ul>
<li>This allows us to write down the full joint density of the training data, <span class="math display">\[
p(\dataVector, \inputMatrix|\paramVector, \pi) = \prod_{i=1}^{\numData} \prod_{j=1}^{\dataDim} p(\inputScalar_{i,j}|\dataScalar_i, \paramVector)p(\dataScalar_i|\pi)
\]</span> which can now be fit by maximum likelihood. </li>
</ul>
</section>
<section id="objective-function" class="slide level2">
<h2>Objective Function</h2>
<p><span class="math display">\[\begin{align*}
\errorFunction(\paramVector, \pi)&amp; =  -\log p(\dataVector, \inputMatrix|\paramVector, \pi) \\ &amp;= -\sum_{i=1}^{\numData} \sum_{j=1}^{\dataDim} \log p(\inputScalar_{i, j}|\dataScalar_i, \paramVector) -  \sum_{i=1}^{\numData} \log p(\dataScalar_i|\pi),
\end{align*}\]</span> </p>
</section>
<section id="maximum-likelihood" class="slide level2">
<h2>Maximum Likelihood</h2>

</section>
<section id="fit-prior" class="slide level2">
<h2>Fit Prior</h2>
<ul>
<li>We can minimize prior. For Bernoulli likelihood over the labels we have, <span class="math display">\[\begin{align*}
\errorFunction(\pi) &amp; = - \sum_{i=1}^{\numData}\log p(\dataScalar_i|\pi)\\ &amp; = -\sum_{i=1}^{\numData} \dataScalar_i \log \pi - \sum_{i=1}^{\numData} (1-\dataScalar_i) \log (1-\pi)
\end{align*}\]</span></li>
<li>Solution from above is <span class="math display">\[
\pi = \frac{\sum_{i=1}^{\numData} \dataScalar_i}{\numData}.
\]</span></li>
</ul>
</section>
<section id="fit-conditional" class="slide level2">
<h2>Fit Conditional</h2>
<ul>
<li>Minimize conditional distribution: <span class="math display">\[
\errorFunction(\paramVector) = -\sum_{i=1}^{\numData} \sum_{j=1}^{\dataDim} \log p(\inputScalar_{i, j} |\dataScalar_i, \paramVector),
\]</span></li>
<li>Implies making an assumption about it’s form.</li>
<li>The right assumption will depend on the data.</li>
<li>E.g. for real valued data, use a Gaussian <span class="math display">\[
p(\inputScalar_{i, j} | \dataScalar_i,\paramVector) =
\frac{1}{\sqrt{2\pi \dataStd_{\dataScalar_i,j}^2}} \exp \left(-\frac{(\inputScalar_{i,j} - \mu_{\dataScalar_i,
j})^2}{\dataStd_{\dataScalar_i,j}^2}\right),
\]</span></li>
</ul>
<p>import urllib.request</p>
<p>urllib.request.urlretrieve(‘https://energydata.info/dataset/f85d1796-e7f2-4630-be84-79420174e3bd/resource/6e640a13-cab4-457b-b9e6-0336051bac27/download/healthmopupandbaselinenmisfacility.csv’, ‘healthmopupandbaselinenmisfacility.csv’)</p>
<p>import pandas as pd</p>
<p>data = pd.read_csv(‘healthmopupandbaselinenmisfacility.csv’)</p>
<p>data.head()</p>
<p>import pandas as pd import numpy as np</p>
<p>data = data[~pd.isnull(data[‘maternal_health_delivery_services’])] data = data.dropna() # Remove entries with missing values X = data[[‘emergency_transport’, ‘num_chews_fulltime’, ‘phcn_electricity’, ‘child_health_measles_immun_calc’, ‘num_nurses_fulltime’, ‘num_doctors_fulltime’, ‘improved_water_supply’, ‘improved_sanitation’, ‘antenatal_care_yn’, ‘family_planning_yn’, ‘malaria_treatment_artemisinin’, ‘latitude’, ‘longitude’]].copy() y = data[‘maternal_health_delivery_services’]==True # set label to be whether there’s a maternal health delivery service</p>
</section>
<section id="create-series-of-health-center-types-with-the-relevant-index" class="title-slide slide level1">
<h1>Create series of health center types with the relevant index</h1>
<p>s = data[‘facility_type_display’].apply(pd.Series, 1).stack() s.index = s.index.droplevel(-1) # to line up with df’s index</p>
</section>

<section id="extract-from-the-series-the-unique-list-of-types." class="title-slide slide level1">
<h1>Extract from the series the unique list of types.</h1>
<p>types = s.unique()</p>
</section>

<section id="for-each-type-extract-the-indices-where-it-is-present-and-add-a-column-to-x" class="title-slide slide level1">
<h1>For each type extract the indices where it is present and add a column to X</h1>
<p>type_names = [] for htype in types: index = s[s==htype].index.tolist() type_col=htype.replace(’ ‘,’_‘).replace(’/‘,’-’).lower() type_names.append(type_col) X.loc[:, type_col] = 0.0 X.loc[index, type_col] = 1.0</p>
<p>X.describe()</p>
</section>

<section id="assume-data-is-binary-or-real." class="title-slide slide level1">
<h1>assume data is binary or real.</h1>

</section>

<section>
<section id="this-list-encodes-whether-it-is-binary-or-real-1-for-binary-0-for-real" class="title-slide slide level1">
<h1>this list encodes whether it is binary or real (1 for binary, 0 for real)</h1>
<p>binary_columns = [‘emergency_transport’, ‘phcn_electricity’, ‘child_health_measles_immun_calc’, ‘improved_water_supply’, ‘improved_sanitation’, ‘antenatal_care_yn’, ‘family_planning_yn’, ‘malaria_treatment_artemisinin’] + type_names real_columns = [‘num_chews_fulltime’, ‘num_nurses_fulltime’, ‘num_doctors_fulltime’, ‘latitude’, ‘longitude’] Bernoulli = pd.DataFrame(data=np.zeros((2,len(binary_columns))), columns=binary_columns, index=[‘theta_0’, ‘theta_1’]) Gaussian = pd.DataFrame(data=np.zeros((4,len(real_columns))), columns=real_columns, index=[‘mu_0’, ‘sigma2_0’, ‘mu_1’, ‘sigma2_1’])</p>
<p>num_train = 20000 indices = np.random.permutation(X.shape[0]) train_indices = indices[:num_train] test_indices = indices[num_train:] X_train = X.iloc[train_indices] y_train = y.iloc[train_indices]==True X_test = X.iloc[test_indices] y_test = y.iloc[test_indices]==True</p>
<p>for column in X_train: if column in Gaussian: Gaussian[column][‘mu_0’] = X_train[column][~y_train].mean() Gaussian[column][‘mu_1’] = X_train[column][y_train].mean() Gaussian[column][‘sigma2_0’] = X_train[column][~y_train].var(ddof=0) Gaussian[column][‘sigma2_1’] = X_train[column][y_train].var(ddof=0) if column in Bernoulli: Bernoulli[column][‘theta_0’] = X_train[column][~y_train].sum()/(~y_train).sum() Bernoulli[column][‘theta_1’] = X_train[column][y_train].sum()/(y_train).sum()</p>
<p>Bernoulli</p>
<p>The distributions show the parameters of the <em>independent</em> class conditional probabilities for no maternity services. It is a Bernoulli distribution with the parameter, <span class="math inline">\(\pi\)</span>, given by (<code>theta_0</code>) for the facilities without maternity services and <code>theta_1</code> for the facilities with maternity services. The parameters whow that, facilities with maternity services also are more likely to have other services such as grid electricity, emergency transport, immunization programs etc.</p>
<p>The naive Bayes assumption says that the joint probability for these services is given by the product of each of these Bernoulli distributions.</p>
<p>Gaussian</p>
<p>We have modelled the numbers in our table with a Gaussian density. Since several of these numbers are counts, a more appropriate distribution might be the Poisson distribution. But here we can see that the average number of nurses, healthworkers and doctors is <em>higher</em> in the facilities with maternal services (<code>mu_1</code>) than those without maternal services (<code>mu_0</code>). There is also a small difference between the mean latitude and longitudes. However, the <em>standard deviation</em> which would be given by the square root of the variance parameters (<code>sigma_0</code> and <code>sigma_1</code>) is large, implying that a difference in latitude and longitude may be due to sampling error. To be sure more analysis would be required.</p>
<p>prior = float(y_train.sum())/len(y_train)</p>
</section>
<section id="compute-posterior-for-test-point-label" class="slide level2">
<h2>Compute Posterior for Test Point Label</h2>
<ul>
<li>We know that <span class="math display">\[
P(\dataScalar^*| \dataVector, \inputMatrix, \inputVector^*, \paramVector)p(\dataVector,\inputMatrix, \inputVector^*|\paramVector) = p(\dataScalar*, \dataVector, \inputMatrix,\inputVector^*| \paramVector)
\]</span></li>
<li>This implies <span class="math display">\[
P(\dataScalar^*| \dataVector, \inputMatrix, \inputVector^*, \paramVector) = \frac{p(\dataScalar*, \dataVector, \inputMatrix, \inputVector^*| \paramVector)}{p(\dataVector, \inputMatrix, \inputVector^*|\paramVector)}
\]</span></li>
</ul>
</section>
<section id="compute-posterior-for-test-point-label-1" class="slide level2">
<h2>Compute Posterior for Test Point Label</h2>
<ul>
<li>From conditional independence assumptions <span class="math display">\[
p(\dataScalar^*, \dataVector, \inputMatrix, \inputVector^*| \paramVector) = \prod_{j=1}^{\dataDim} p(\inputScalar^*_{j}|\dataScalar^*, \paramVector)p(\dataScalar^*|\pi)\prod_{i=1}^{\numData} \prod_{j=1}^{\dataDim} p(\inputScalar_{i,j}|\dataScalar_i, \paramVector)p(\dataScalar_i|\pi)
\]</span></li>
<li>We also need <span class="math display">\[
p(\dataVector, \inputMatrix, \inputVector^*|\paramVector)\]</span> which can be found from <span class="math display">\[p(\dataScalar^*, \dataVector, \inputMatrix, \inputVector^*| \paramVector)
\]</span></li>
<li>Using the <em>sum rule</em> of probability, <span class="math display">\[
p(\dataVector, \inputMatrix, \inputVector^*|\paramVector) = \sum_{\dataScalar^*=0}^1 p(\dataScalar^*, \dataVector, \inputMatrix, \inputVector^*| \paramVector).
\]</span></li>
</ul>
</section>
<section id="independence-assumptions" class="slide level2">
<h2>Independence Assumptions</h2>
<ul>
<li>From independence assumptions <span class="math display">\[
p(\dataVector, \inputMatrix, \inputVector^*| \paramVector) = \sum_{\dataScalar^*=0}^1 \prod_{j=1}^{\dataDim} p(\inputScalar^*_{j}|\dataScalar^*_i, \paramVector)p(\dataScalar^*|\pi)\prod_{i=1}^{\numData} \prod_{j=1}^{\dataDim} p(\inputScalar_{i,j}|\dataScalar_i, \paramVector)p(\dataScalar_i|\pi).
\]</span></li>
<li>Substitute both forms to recover, <span class="math display">\[
P(\dataScalar^*| \dataVector, \inputMatrix, \inputVector^*, \paramVector)  = \frac{\prod_{j=1}^{\dataDim} p(\inputScalar^*_{j}|\dataScalar^*_i, \paramVector)p(\dataScalar^*|\pi)\prod_{i=1}^{\numData} \prod_{j=1}^{\dataDim} p(\inputScalar_{i,j}|\dataScalar_i, \paramVector)p(\dataScalar_i|\pi)}{\sum_{\dataScalar^*=0}^1 \prod_{j=1}^{\dataDim} p(\inputScalar^*_{j}|\dataScalar^*_i, \paramVector)p(\dataScalar^*|\pi)\prod_{i=1}^{\numData} \prod_{j=1}^{\dataDim} p(\inputScalar_{i,j}|\dataScalar_i, \paramVector)p(\dataScalar_i|\pi)}
\]</span></li>
</ul>
</section>
<section id="cancelation" class="slide level2">
<h2>Cancelation</h2>
<ul>
<li>Note training data terms cancel. <span class="math display">\[
p(\dataScalar^*| \inputVector^*, \paramVector) = \frac{\prod_{j=1}^{\dataDim} p(\inputScalar^*_{j}|\dataScalar^*_i, \paramVector)p(\dataScalar^*|\pi)}{\sum_{\dataScalar^*=0}^1 \prod_{j=1}^{\dataDim} p(\inputScalar^*_{j}|\dataScalar^*_i, \paramVector)p(\dataScalar^*|\pi)}
\]</span></li>
<li>This formula is also fairly straightforward to implement for different class conditional distributions.</li>
</ul>
</section>
<section id="laplace-smoothing" class="slide level2">
<h2>Laplace Smoothing</h2>
<iframe frameborder="0" scrolling="no" style="border:0px" src="http://books.google.co.uk/books?id=1YQPAAAAQAAJ&amp;pg=PA16&amp;output=embed" width="700" height="500">
</iframe>
</section>
<section id="pseudo-counts" class="slide level2">
<h2>Pseudo Counts</h2>
<p><span class="math display">\[
\pi = \frac{\sum_{i=1}^{\numData} \dataScalar_i + 1}{\numData + 2}
\]</span> </p>
</section></section>
<section>
<section id="fit-the-bernoulli-with-laplace-smoothing." class="title-slide slide level1">
<h1>fit the Bernoulli with Laplace smoothing.</h1>
<p>for column in X_train: if column in Bernoulli: Bernoulli[column][‘theta_0’] = (X_train[column][~y_train].sum() + 1)/((~y_train).sum() + 2) Bernoulli[column][‘theta_1’] = (X_train[column][y_train].sum() + 1)/((y_train).sum() + 2)</p>
<p>import numpy as np import pandas as pd</p>
<p>def predict(X_test, Gaussian, Bernoulli, prior): log_positive = pd.Series(data = np.zeros(X_test.shape[0]), index=X_test.index) log_negative = pd.Series(data = np.zeros(X_test.shape[0]), index=X_test.index) for column in X_test.columns: if column in Gaussian: log_positive += log_gaussian(X_test[column], Gaussian[column][‘mu_1’], Gaussian[column][‘sigma2_1’]) log_negative += log_gaussian(X_test[column], Gaussian[column][‘mu_0’], Gaussian[column][‘sigma2_0’]) elif column in Bernoulli: log_positive += log_bernoulli(X_test[column], Bernoulli[column][‘theta_1’]) log_negative += log_bernoulli(X_test[column], Bernoulli[column][‘theta_0’])</p>
<pre><code>v = np.zeros_like(log_positive.values)
for i in range(X_test.shape[0]):
    v[i] = np.exp(log_positive.values[i] + np.log(prior))/(np.exp(log_positive.values[i] + np.log(prior)) 
                                                           + np.exp(log_negative.values[i] + np.log(1-prior)))
return v
#return np.exp(log_positive + np.log(prior))/(np.exp(log_positive + np.log(prior)) + np.exp(log_negative + np.log(1-prior)))</code></pre>
<p>p_y = predict(X_test, Gaussian, Bernoulli, prior)</p>
<p>\notes{We can test the quality of the predictions in the following way. Firstly, we can threshold our probabilities at 0.5, allocating points with greater than 50% probability of membership of the positive class to the positive class. We can then compare to the true values, and see how many of these values we got correct. This is our total number correct.}</p>
<p>correct = y_test.eq(p_y&gt;0.5) total_correct = sum(correct) print(“Total correct”, total_correct, " out of “, len(y_test),”which is“, float(total_correct)/len(y_test),”%")</p>
<p>confusion_matrix = pd.DataFrame(data=np.zeros((2,2)), columns=[‘predicted no maternity’, ‘predicted maternity’], index =[‘actual no maternity’,‘actual maternity’]) confusion_matrix[‘predicted maternity’][‘actual maternity’] = (y_test &amp; (p_y&gt;0.5)).sum() confusion_matrix[‘predicted maternity’][‘actual no maternity’] = (~y_test &amp; (p_y&gt;0.5)).sum() confusion_matrix[‘predicted no maternity’][‘actual maternity’] = (y_test &amp; ~(p_y&gt;0.5)).sum() confusion_matrix[‘predicted no maternity’][‘actual no maternity’] = (~y_test &amp; ~(p_y&gt;0.5)).sum() confusion_matrix</p>
</section>
<section id="exercise-3" class="slide level2">
<h2>Exercise 3</h2>
<p>How can you improve your classification, are all the features equally valid? Are some features more helpful than others? What happens if you remove features that appear to be less helpful. How might you select such features?</p>
</section>
<section id="exercise-4" class="slide level2">
<h2>Exercise 4</h2>
<p>We have decided to classify positive if probability of maternity is greater than 0.5. This has led us to accidentally classify some facilities as havien’t facilities for maternity when in fact they don’t. Imagine you wish to ensure that a facility handles maternity. With your test set how low do you have to set the threshold to avoid all the false negatives (i.e. facilities where you predicted there was no maternity, but in actuality there were?</p>
</section>
<section id="naive-bayes-summary" class="slide level2">
<h2>Naive Bayes Summary</h2>
<ul>
<li>Model <em>full</em> joint distribution of data, <span class="math inline">\(p(\dataVector, \inputMatrix | \paramVector, \pi)\)</span></li>
<li>Make conditional independence assumptions about the data.
<ul>
<li>feature conditional independence</li>
<li>data conditional independence</li>
</ul></li>
<li>Fast to implement, works on very large data.</li>
<li>Despite simple assumptions can perform better than expected.</li>
</ul>
</section>
<section id="further-reading" class="slide level2 scrollable">
<h2 class="scrollable">Further Reading</h2>
<ul>
<li>Chapter 5 up to pg 179 (Section 5.1, and 5.2 up to 5.2.2) of <span class="citation" data-cites="Rogers:book11">Rogers and Girolami (2011)</span></li>
</ul>
</section>
<section id="thanks" class="slide level2 scrollable">
<h2 class="scrollable">Thanks!</h2>
<ul>
<li>twitter: <a href="https://twitter.com/lawrennd">@lawrennd</a></li>
<li>podcast: <a href="http://thetalkingmachines.com">The Talking Machines</a></li>
<li>newspaper: <a href="http://www.theguardian.com/profile/neil-lawrence">Guardian Profile Page</a></li>
<li>blog: <a href="http://inverseprobability.com/blog.html">http://inverseprobability.com</a></li>
</ul>
</section>
<section id="references" class="slide level2 unnumbered scrollable">
<h2 class="unnumbered scrollable">References</h2>
<div id="refs" class="references hanging-indent" role="doc-bibliography">
<div id="ref-Bayes:doctrine63">
<p>Bayes, T., 1763. An essay towards solving a problem in the doctrine of chances. Philosophical Transactions of the Royal Society 53, 370–418. <a href="https://doi.org/10.1098/rstl.1763.0053">https://doi.org/10.1098/rstl.1763.0053</a></p>
</div>
<div id="ref-Laplace:memoire74">
<p>Laplace, P.S., 1774. Mémoire sur la probabilité des causes par les évènemens, in: Mémoires de Mathèmatique et de Physique, Presentés à lAcadémie Royale Des Sciences, Par Divers Savans, &amp; Lù Dans Ses Assemblées 6. pp. 621–656.</p>
</div>
<div id="ref-Rogers:book11">
<p>Rogers, S., Girolami, M., 2011. A first course in machine learning. CRC Press.</p>
</div>
</div>
</section></section>
    </div>
  </div>

  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Push each slide change to the browser history
        history: true,
        math: {
          mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js',
          config: 'TeX-AMS_HTML-full',
          tex2jax: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
            balanceBraces: true,
            processEscapes: false,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
          },
        },

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/math/math.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true }
        ]
      });
    </script>
    </body>
</html>
